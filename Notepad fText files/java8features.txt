Java 8 provides following features for Java Programming:

1.Lambda expressions,
2.Method references,
3.Functional interfaces,
4.Optional class,
5.Stream API,
6.Collectors class,

=========================================================================================================================================

1. Lambda Expressions :- Lambda expression is an implementation of functional interface and less code. 
		         Lamda Expression is a annonoyomous function.
                         which have no name , no modifier and no return type.
			 
			 Lamda Syntak - Argument List , arrow token and body. 
                         

2. Method references :- A method reference is similar to a lambda expression that refers a method without executing it.
                        you can replace your lambda expression with method reference.
			it is a compact and easy form of LE.

                        There are three types of method reference:
                        1. Reference to a static method.
                        2. Reference to an instance method.
                        3. Reference to a constructor.

3. Functional Interface :- A functional interface is an interface that contains only one abstract method.
                           Functional interfaces are also known as Single Abstract Method (SAM) interfaces.
			   They can have any number of default and static methods.
			   Functional interfaces can also declare methods of the Object class.
			   Functional interfaces are a new feature in Java that facilitates functional programming.
			   The @FunctionalInterface annotation is used to denote a functional interface.

   Java Predefined-Functional Interfaces:-
   Example :- BiFunction<T,U> , Consumer<T> ,Function<T,R> ,Predicate<T> , BiFunction<T,U,R> , BiPredicate<T,U>

4. Optional :- It is a public final class and used to deal with NullPointerException in Java.
               Methods :- its provide many methods:- Optional.empty, of , else , ofNullable, isPresent , isEmpty. ( To Check The Presence of Value For Particular Variable)

5. Collectors class :- The Collectors class is a final class in Java.
                       It extends the Object class.
                       It is used for performing reduction operations on data.

6.Stream API :- Stream API:

The Stream API in Java provides a wide range of methods that allow you to perform various operations on streams of data. These operations can be categorized into two main types: intermediate and terminal operations.

Intermediate Operations:

Intermediate operations return a new stream and allow you to perform transformations and filtering on the data in the stream.

filter(Predicate<T> predicate): Filters the elements in the stream based on the given predicate.
Example:

java
Copy code
stream.filter(x -> x % 2 == 0); // Filters even numbers
map(Function<T, R> mapper): Transforms each element in the stream using the provided mapping function.
Example:

java
Copy code
stream.map(String::toUpperCase); // Converts each element to uppercase
flatMap(Function<T, Stream<R>> mapper): Similar to map, but it flattens the result, which can be a Stream of elements.
Example:

java
Copy code
stream.flatMap(line -> Arrays.stream(line.split(" ")); // Splits lines into words
distinct(): Removes duplicate elements from the stream.
Example:

java
Copy code
stream.distinct(); // Removes duplicates
sorted() and sorted(Comparator<T> comparator): Sorts the elements in the stream in their natural order or according to the provided comparator.
Examples:

java
Copy code
stream.sorted(); // Sorts in natural order
stream.sorted((a, b) -> b.compareTo(a)); // Sorts in reverse order
peek(Consumer<T> action): Performs an action on each element in the stream and returns the original stream, often used for debugging.
Example:

java
Copy code
stream.peek(System.out::println); // Prints each element and returns the original stream
Terminal Operations:

Terminal operations close the stream and produce a result or a side effect.

forEach(Consumer<T> action): Performs an action on each element in the stream.
Example:

java
Copy code
stream.forEach(System.out::println); // Prints each element
collect(Collector<T, A, R> collector): Collects the elements of the stream into a collection or other data structure specified by the collector.
Example:

java
Copy code
List<String> list = stream.collect(Collectors.toList());
toArray(): Converts the stream into an array.
Example:

java
Copy code
Object[] array = stream.toArray();
count(): Returns the count of elements in the stream.
Example:

java
Copy code
long count = stream.count();
anyMatch(Predicate<T> predicate): Checks if any element in the stream matches the given predicate.
Example:

java
Copy code
boolean anyMatch = stream.anyMatch(x -> x > 10); // Checks if any element is greater than 10
allMatch(Predicate<T> predicate): Checks if all elements in the stream match the given predicate.
Example:

java
Copy code
boolean allMatch = stream.allMatch(x -> x > 0); // Checks if all elements are positive
noneMatch(Predicate<T> predicate): Checks if no elements in the stream match the given predicate.
Example:

java
Copy code
boolean noneMatch = stream.noneMatch(x -> x < 0); // Checks if no elements are negative
min(Comparator<T> comparator) and max(Comparator<T> comparator): Returns the minimum and maximum elements in the stream according to the provided comparator.
Examples:

java
Copy code
Optional<Integer> min = stream.min(Comparator.naturalOrder());
Optional<Integer> max = stream.max(Comparator.reverseOrder());
reduce(): Performs a reduction on the elements of the stream. It can be used to perform various aggregate operations.
Example:

java
Copy code
int sum = stream.reduce(0, (a, b) -> a + b); // Computes the sum
findFirst() and findAny(): Returns the first element or any element from the stream (useful for short-circuiting operations).
Example:

java
Copy code
Optional<T> first = stream.findFirst();
Optional<T> any = stream.findAny();
Features:

Stream does not store elements.
Stream is functional in nature.
Stream is lazy and evaluates code only when required.
Use:

You can use streams to filter, collect, print, and convert from one data structure to another, among other operations.


 


               
